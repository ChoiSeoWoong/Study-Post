# [Mysql] 인덱스-1

<hr>

# 클러스터링 인덱스
- 어원 : 군집
- 프라이머리 키값이 비슷한 레코드끼리 묶어서 저장한 것을 클러스터링 인덱스라고 함
- 프라이머리 키를 기준으로 인덱싱하고 항상 정렬되어 있음
- 클러스터링 인덱스는 범위 검색 ex) where id < 5 and id >10 와 같은 검색에서 유리함
- innodb는 기본적으로 프라이머리 키 순서로 레코드를 저장한다.
  프라이머리 키를 기준으로 인덱싱하는 클러스터링 인덱스를 범위 검색에(연속된 데이터) 이용하면 innodb 프라이머리 키 특성상
  물리적으로 가까이 데이터를 저장하기 때문에 한 블록에 원하는 데이터를 가져올 가능성이 높다.
  따라서 일반 인덱스에 비해 범위 검색 성능이 더 좋다.

<hr>

# 논 클러스터링 인덱스
- 데이터와 직접적으로 연결되어 있지 않고 pk를 참조하는 인덱스를 말함
- 데이터가 물리적으로 정렬이 되어있진 않음.

<hr>

# DB에서 B-tree를 사용하는 이유
## B-tree 란?
![](http://vitalflux.com/wp-content/uploads/2015/05/btree-order5.jpg)
- B-tree는 Balanced의 B를 따서 Btree라고 한다. 이진 트리가 아니기 때문에 두 개 이상의 자식 노드를 가질 수 있다.
- 사진과 같이 한 개의 노드에 여러값을 선형으로 배치할 수 있다.

## B-tree를 사용하지 않고 선형 데이터구조를 사용할 때 단점
- 인덱스는 크기가 커서 메모리에 저장할 수 없다 따라서 디스크에 저장해야 하는데 만약 배열과 같은 구조로 저장하게 되면 디스크는 매우 느리기 때문에 인덱스 검색 시에
  성능상 이슈가 생길 수 있다.
- 검색 속도가 매우 느리다 os는 블록 단위로 디스크에서 데이터를 조회하는데 인덱스가 선형 구조로 replay 될 경우 최악에 경우에는 모든 데이터를 검색해야 할 수도 있다.
- 또 인덱스는 정렬된 방식으로 사용되는데 배열 구조로 사용 시에 재정렬하기 어렵다.

## B-tree를 사용했을 때 장점
- 검색 시에 root - branch - leaf 노드를 거쳐서 빠르게 인덱스를 검색할 수 있다.
- 추가적으로 일반 노드와 다르게 한 개의 인덱스만 노드에 저장하는 게 아니라 여 러키를 저장해서 같은 레벨의 노드끼리 추가적인 탐색 없이 선형적으로 데이터를 가져올 수 있어서 I/O 횟수를 줄일 수 있다.
- I/O의 횟수가 줄기 때문에 자연스럽게 검색 속도도 빨라진다.

> 출처: https://vitalflux.com/dummies-notes-what-is-b-tree-and-why-use-them/